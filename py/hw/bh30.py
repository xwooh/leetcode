"""
区间交集

题目描述

给定一组闭区间，其中部分区间存在交集。

任意两个给定区间的交集，称为公共区间
如:[1,2],[2,3]的公共区间为[2,2],
[3,5],[3,6]的公共区间为[3,5]

公共区间之间若存在交集，则需要合并
如:[1,3],[3,5]区间存在交集[3,3],需合并为[1,5]。

按升序排列输出合并后的区间列表

输入描述

组区间列表

区间数为 N: O<=N<=1000。

区间元素为 X:-10000<=X<=10000。

输出描述

升序排列的合并区间列表

备注

1、区间元素均为数字，不考虑字母、符号等异常输入。

2、单个区间认定为无公共区间。
"""


def combine(ls: list[list]) -> list[list]:
    """
    [ [0,3], [1,3], [3,5], [3,6] ]
    """

    ls.sort(key=lambda x: x[0])

    # 取交集
    # 挨个取交集
    cs = []
    i = 0
    while i < len(ls):
        j = i + 1
        while j < len(ls):
            if ls[i][1] < ls[j][0]:
                break

            s, e = max(ls[i][0], ls[j][0]), min(ls[i][1], ls[j][1])
            # 过滤掉相同区间
            if not (cs and cs[-1][0] == s and cs[-1][1] == e):
                cs.append([s, e])
            j += 1
        i += 1

    # 合并区间
    # 以第一个为基准，能合并就合并进来，不能合的就追加进来
    cs.sort(key=lambda x: (x[0], x[1]))
    ans = [cs[0]]
    j = 1
    while j < len(cs):
        if ans[-1][1] < cs[j][0]:
            ans.append(cs[j])
        else:
            # 吞掉当前区间
            s, e = min(ans[-1][0], cs[j][0]), max(ans[-1][1], cs[j][1])
            ans[-1] = [s, e]
        j += 1

    return ans


if __name__ == "__main__":
    print(combine([[0, 3], [1, 3], [3, 5], [3, 6]]))
    print(combine([[0, 3], [1, 4], [4, 7], [5, 9]]))
    print(combine([[0, 6], [3, 4], [3, 5], [3, 6], [4, 7]]))
